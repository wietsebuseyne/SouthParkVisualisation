<!DOCTYPE html>
<meta charset="utf-8">
<html>
  <head>
    <title>South Park Text Analysis</title>
    <style>
      rect.bordered {
        stroke: #555;
        stroke-width:1px;
      }

      text.mono {
        font-size: 9pt;
        font-family: Consolas, courier;
        fill: #aaa;
      }

      text.axis-workweek {
        fill: #000;
      }

      text.axis-worktime {
        fill: #000;
      }

      .inScope {
        -webkit-filter: grayscale(100%); /* Chrome, Safari, Opera */
        filter: grayscale(100%);
      }

	  .tooltip {
		background: #eee;
        box-shadow: 0 0 5px #999999;
        color: #333;
        display: none;
        font-size: 12px;
        left: 130px;
        padding: 10px;
        position: absolute;
        text-align: center;
        top: 95px;
        width: 100px;
        z-index: 10;
      }
    </style>
    <script src="d3.v3.min.js"></script>
  </head>
  <body>
	<div class="filter_options">
		<input class="filter_button" id="b_button" type="checkbox" value="Clyde">Clyde</input><br>
		<input class="filter_button" id="c_button" type="checkbox" value="Craig">Craig</input><br>
	</div>
    <div id="chart"></div>
    <div id="nav"></div>
    <div id="dataset-picker">
    </div>
    <script type="text/javascript">
    // Source: http://bl.ocks.org/tjdecke/5558084
    // Alternative: http://bl.ocks.org/mbostock/3202354

		var seasonMap =
			[
				[1,13],  [2,18],  [3,17],
				[4,17],  [5,14],  [6,17],
				[7,15],  [8,14],  [9,14],
				[10,14], [11,14], [12,14],
				[13,14], [14,14], [15,14],
				[16,14], [17,10], [18,10]
			];
        
        var episodeMap = 
            {
                1 : 1, 2 : 2, 3 : 3, 4 : 4, 5 : 5, 6 : 6, 7 : 7, 8 : 8, 9 : 9, 10 : 10, 11 : 11, 12 : 12, 13 : 13, 14 : 1, 15 : 2, 16 : 3, 17 : 4, 18 : 5, 19 : 6, 20 : 7, 21 : 8, 22 : 9, 23 : 10, 24 : 11, 25 : 12, 26 : 13, 27 : 14, 28 : 15, 29 : 16, 30 : 17, 31 : 18, 32 : 1, 33 : 2, 34 : 3, 35 : 4, 36 : 5, 37 : 6, 38 : 7, 39 : 8, 40 : 9, 41 : 10, 42 : 11, 43 : 12, 44 : 13, 45 : 14, 46 : 15, 47 : 16, 48 : 17, 49 : 1, 50 : 2, 51 : 3, 52 : 4, 53 : 5, 54 : 6, 55 : 7, 56 : 8, 57 : 9, 58 : 10, 59 : 11, 60 : 12, 61 : 13, 62 : 14, 63 : 15, 64 : 16, 65 : 17, 66 : 1, 67 : 2, 68 : 3, 69 : 4, 70 : 5, 71 : 6, 72 : 7, 73 : 8, 74 : 9, 75 : 10, 76 : 11, 77 : 12, 78 : 13, 79 : 14, 80 : 1, 81 : 2, 82 : 3, 83 : 4, 84 : 5, 85 : 6, 86 : 7, 87 : 8, 88 : 9, 89 : 10, 90 : 11, 91 : 12, 92 : 13, 93 : 14, 94 : 15, 95 : 16, 96 : 17, 97 : 1, 98 : 2, 99 : 3, 100 : 4, 101 : 5, 102 : 6, 103 : 7, 104 : 8, 105 : 9, 106 : 10, 107 : 11, 108 : 12, 109 : 13, 110 : 14, 111 : 15, 112 : 1, 113 : 2, 114 : 3, 115 : 4, 116 : 5, 117 : 6, 118 : 7, 119 : 8, 120 : 9, 121 : 10, 122 : 11, 123 : 12, 124 : 13, 125 : 14, 126 : 1, 127 : 2, 128 : 3, 129 : 4, 130 : 5, 131 : 6, 132 : 7, 133 : 8, 134 : 9, 135 : 10, 136 : 11, 137 : 12, 138 : 13, 139 : 14, 140 : 1, 141 : 2, 142 : 3, 143 : 4, 144 : 5, 145 : 6, 146 : 7, 147 : 8, 148 : 9, 149 : 10, 150 : 11, 151 : 12, 152 : 13, 153 : 14, 154 : 1, 155 : 2, 156 : 3, 157 : 4, 158 : 5, 159 : 6, 160 : 7, 161 : 8, 162 : 9, 163 : 10, 164 : 11, 165 : 12, 166 : 13, 167 : 14, 168 : 1, 169 : 2, 170 : 3, 171 : 4, 172 : 5, 173 : 6, 174 : 7, 175 : 8, 176 : 9, 177 : 10, 178 : 11, 179 : 12, 180 : 13, 181 : 14, 182 : 1, 183 : 2, 184 : 3, 185 : 4, 186 : 5, 187 : 6, 188 : 7, 189 : 8, 190 : 9, 191 : 10, 192 : 11, 193 : 12, 194 : 13, 195 : 14, 196 : 1, 197 : 2, 198 : 3, 199 : 4, 200 : 5, 201 : 6, 202 : 7, 203 : 8, 204 : 9, 205 : 10, 206 : 11, 207 : 12, 208 : 13, 209 : 14, 210 : 1, 211 : 2, 212 : 3, 213 : 4, 214 : 5, 215 : 6, 216 : 7, 217 : 8, 218 : 9, 219 : 10, 220 : 11, 221 : 12, 222 : 13, 223 : 14, 224 : 1, 225 : 2, 226 : 3, 227 : 4, 228 : 5, 229 : 6, 230 : 7, 231 : 8, 232 : 9, 233 : 10, 234 : 11, 235 : 12, 236 : 13, 237 : 14, 238 : 1, 239 : 2, 240 : 3, 241 : 4, 242 : 5, 243 : 6, 244 : 7, 245 : 8, 246 : 9, 247 : 10, 248 : 1, 249 : 2, 250 : 3, 251 : 4, 252 : 5, 253 : 6, 254 : 7, 255 : 8, 256 : 9, 257 : 10
            };
        
        var episodes = [];
        var sum = 0;
        // Create array of 0...N
        seasonMap.forEach(function(s) {
            episodes.push.apply(episodes, Array.apply(null, Array(s[1])).map(function (_, i) {return i+sum+1;}));
            sum += s[1];
        });
      function palette(min, max) {
    var d = (max-min)/15;
    return d3.scale.threshold()
        .range(['#ffffe0','#ffedbf','#ffdaa3','#ffc88d','#ffb27c','#ff9c70','#fb8768','#f47461','#eb5f5b','#df4c54','#d3394a','#c3273e','#b3152f','#9f051c','#8b0000'])
        .domain([min+1*d,min+2*d,min+3*d,min+4*d,min+5*d,min+6*d,min+7*d,min+8*d,min+9*d,min+10*d,min+11*d,min+12*d,min+13*d,min+14*d,min+15*d]);
}

      var characters = ["Cartman", "Kyle", "Stan", "Kenny", "Butters", "Chef", "Randy", "Wendy", "Mr. Garrison", "Clyde", "Craig"],
          margin = { top: 50, right: 0, bottom: 30, left: 100 },
          shownEpisodes = 50,
          startEpisode = 0,
          gridSize = 20,
          navTileSize = gridSize*shownEpisodes/episodes.length,
          width = gridSize*shownEpisodes,
          height = characters.length * gridSize,
          legendElementWidth = gridSize*3,
          buckets = 9,
          /*colors = ["#ffffd9","#edf8b1","#c7e9b4","#7fcdbb","#41b6c4","#1d91c0","#225ea8","#253494","#081d58", "#ff8080", "#ff1a1a", "#660000", "#330000"], // alternatively colorbrewer.YlGnBu[9];*/
          colors = /*['#ffffe0','#ffedbf','#ffdaa3','#ffc88d','#ffb27c','#ff9c70','#fb8768','#f47461','#eb5f5b','#df4c54','#d3394a','#c3273e','#b3152f','#9f051c','#8b0000'],*/["#ffffe5","#fff7bc","#fee391","#fec44f","#fe9929","#ec7014","#cc4c02","#993404","#662506"];

      var svg = d3.select("#chart").append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      var svgNav = d3.select("#nav").append("svg")
          .attr("width", (navTileSize*episodes.length) + margin.left + margin.right)
          .attr("height", navTileSize * characters.length)
          .append("g")
          .attr("transform", "translate(" + margin.left + ",0 )");

      var characterLabels = svg.selectAll(".dayLabel")
          .data(characters)
          .enter().append("text")
            .text(function (d) { return d; })
            .attr("x", 0)
            .attr("y", function (d, i) { return i * gridSize; })
            .style("text-anchor", "end")
            .attr("transform", "translate(-6," + gridSize / 1.5 + ")")
            .attr("class", "dayLabel mono axis axis-workweek")
            .on("click", function(c,i) {
              //TODO toggle selection of character and redraw
            });
    
    var scalePoints = [0, 5, 10, 15, 20, 30, 40, 80, 100, 1000];

		// TOOLTIP
		var tooltip = d3.select('#chart')
          .append('div')
          .attr('class', 'tooltip');

        tooltip.append('div')
          .attr('class', 'character');

        tooltip.append('div')
          .attr('class', 'episode');

        tooltip.append('div')
          .attr('class', 'count');

      var heatmapChart = function(tsvFile) {
        d3.tsv(tsvFile,
        function(d) {
          return {
            character: +d.character,
            episode: +d.episode,
            words: +d.words,
            profanities: +d.profanities
          };
        }, heatmapDrawer);
      };
      var heatmapDrawer = function(error, data) {
          labelData = episodes.slice(startEpisode, startEpisode+50);
          var episodeLabels = svg.selectAll(".timeLabel")
            .data(labelData);
          var marginScale = d3.scale.linear()
              .domain([0, 40])
              .range([gridSize/3, 0]);

          episodeLabels
            .enter().append("text")
              .attr("x", function(d, i) { return i * gridSize; })
              .attr("y", 0)
              .style("text-anchor", "middle")
              .attr("transform", "translate(" + gridSize / 2 + ", -6)")
              
          episodeLabels.transition().duration(500)
              .text(function(d) { return episodeMap[d]; })
                .attr("class", function(d) {
                    evenSeason = test_season(d);
                    if(evenSeason)
                        return "timeLabel mono axis axis-worktime";
                    else
                        return "timeLabel mono axis";
                });

          //TODO one colorscale for whole heatmap
          /*var colorScale = d3.scale.linear()
              .domain([0, buckets - 1, d3.max(data, function (d) { return d.value; })])
              .range(['#ffffe0','#8b0000']);*/

          var colorScale = d3.scale.quantile()
              .domain(scalePoints)
              .range(colors);
			
          var cards = svg.selectAll(".episode")
              .data(data, function(d) {return d.character+':'+d.episode;});

          cards.append("title");

          cards.enter().append("rect")
              .attr("x", function(d) { return (d.episode - 1) * gridSize + marginScale(d.words); })
              .attr("y", function(d) { return (d.character - 1) * gridSize + marginScale(d.words); })
              .attr("class", "episode bordered")
              .attr("width", function(d) { return gridSize - marginScale(d.words)*2; })
              .attr("height", function(d) { return gridSize - marginScale(d.words)*2; })
              .style("fill", colors[0]);

          cards.transition().duration(0)
              .attr("x", function(d) { return (d.episode - 1) * gridSize + marginScale(d.words); })
              .attr("y", function(d) { return (d.character - 1) * gridSize + marginScale(d.words); })
              .attr("class", "episode bordered")
              .attr("width", function(d) { return gridSize - marginScale(d.words)*2; })
              .attr("height", function(d) { return gridSize - marginScale(d.words)*2; })
              .style("fill", function(d) { return colorScale(d.profanities); });

		      // TOOLTIP
		      cards.on('mouseover', function(d) {
            tooltip.select('.character').html(characters[d.character-1]);
            tooltip.select('.episode').html(mapEpisodeToNotation(d.episode+startEpisode) + "</br>Words: <b>" + d.words + "%</b></br>Profanities: <b>" + d.profanities + "‰</b>");
            tooltip.style('display', 'block');
          });
		  
		

          cards.on('mouseout', function() {
            tooltip.style('display', 'none');
          });

          cards.on('mousemove', function(d) {
            tooltip.style('top', (d3.event.layerY + 10) + 'px')
              .style('left', (d3.event.layerX + 10) + 'px');
          });

          cards.exit().remove();

          var legend = svg.selectAll(".legend")
              .data([0].concat(colorScale.quantiles()), function(d) { return d; });

          legend.enter().append("g")
              .attr("class", "legend");

          legend.append("rect")
            .attr("x", function(d, i) { return legendElementWidth * i; })
            .attr("y", height)
            .attr("width", legendElementWidth)
            .attr("height", gridSize / 2)
            .style("fill", function(d, i) { return colors[i]; });

          legend.append("text")
            .attr("class", "mono")
            .text(function(d) { return "≥ " + Math.round(d); })
            .attr("x", function(d, i) { return legendElementWidth * i; })
            .attr("y", height + gridSize);

          legend.exit().remove();

        };

      heatmapChart("combination.tsv");
	d3.selectAll(".filter_button").on("change", function() {
			
			var character = this.value, 
			// I *think* "inline" is the default.
			display = this.checked ? "inline" : "none";
		console.log(this.value);
			svg.selectAll(".episode")
				.filter(function(d) { return d.character === character; })
				.attr("display", display);
		});
      var nav = function(tsvFile) {
        d3.tsv(tsvFile,
        function(d) {
          return {
            character: +d.character,
            episode: +d.episode,
            words: +d.words,
            profanities: +d.profanities
          };
        },
        function(error, data) {
          var colorScale = d3.scale.quantile()
              .domain(scalePoints)
              .range(colors);

          var cards = svgNav.selectAll(".episodeNav")
              .data(data, function(d) {return d.character+':'+d.episode;});

          cards.enter().append("rect")
              .attr("x", function(d) { return (d.episode - 1) * navTileSize; })
              .attr("y", function(d) { return (d.character - 1) * navTileSize; })
              .attr("width", navTileSize)
              .attr("height", navTileSize)
              .style("fill", colors[0]);

          cards.on('mouseover', function(d, i) {
                //Minimally show 50
                var toSplice = Math.max(0, Math.min(
                  i - (i % characters.length) - (shownEpisodes/2 * characters.length),
                  data.length - shownEpisodes * characters.length));
                startEpisode = toSplice / 11;

                //Show selection in navigation bar
                cards.transition().duration(0).attr("class", function(d) {
                  if(d.episode > startEpisode && d.episode <= startEpisode + shownEpisodes)
                    return "inScope";
                });

                //Update heatmap with selected data
                var newData = [];
                //newData.splice(0, toSplice);
                for(var ep = 0; ep < shownEpisodes ; ep++) {
                  for(var c = 0; c < characters.length; c++) {
                    var index = (ep*characters.length)+c;
                    newData[index] = {
                      "episode": ep+1,
                      "character": data[index+toSplice].character,
                      "words": data[index+toSplice].words,
                      "profanities": data[index+toSplice].profanities
                    };
                  }
                }
                heatmapDrawer(null, newData);
                /*var change = svg.selectAll(".timeLabel")
                  .transition();
      change
            .text(function(d) { return d; })
            .attr("x", function(d, i) { return i * gridSize; })
            .attr("y", 0)
            .style("text-anchor", "middle")
            .attr("transform", "translate(" + gridSize / 2 + ", -6)")
            .attr("class", function(d, i) { return (((i >= 0 && i < 13) || (i>=31 && i < 41)) ? "timeLabel mono axis axis-worktime" : "timeLabel mono axis"); });*/
                /*var c = svg.selectAll(".episode")
                  .data(data, function(d) {return d.character+':'+d.episode;});


                  c.enter().append("rect")
                      .attr("x", function(d) { return (d.episode - 1) * gridSize; })
                      .attr("y", function(d) { return (d.character - 1) * gridSize; })
                      .attr("class", "episode bordered")
                      .attr("width", gridSize)
                      .attr("height", gridSize)
                      .style("fill", colors[0]);

                c.transition().duration(1000)
                      .style("fill", function(d) { return colorScale(d.value); });*/
              });

          cards.transition().duration(0)
              .style("fill", function(d) { return colorScale(d.profanities); });

          cards.exit().remove();

        });
      };

      nav("combination.tsv");

	function mapEpisodeToNotation(episode)
	{
		var season = 1;
		var result = "S0E0";
		seasonMap.forEach(function(entry) {
			if(episode <= entry[1])
				result = "S" + season + "E" + episode;
			else if(result == "S0E0")
			{
				episode -= entry[1];
				season++;
			}
		});
		return result;
	}
        function to_relative_episodes(episodes) {
            output = [];
            episodes.forEach(function(episode) {
                output.push(episodeMap[episode]);
            });
        }
        
    function test_season(episode)
	{
        result = true;
        stop = false;
        seasonMap.forEach(function(entry) {
			if(episode <= entry[1])
                stop = true;
			else if(!stop)
			{
                result = (result) ? false : true;
				episode -= entry[1];
			}
		});
        
		return result;
	}
    </script>
  </body>
</html>
